module uart_transmitter_controler #(
    param CLOCK_FREQUENCY: logic<32> = 32'd100_000_000,
    param BAUD_RATE      : logic<32> = 32'd115200     ,
    param WORD_WIDTH     : logic<32> = 32'd8          ,
) (
    clk  : input  clock            ,
    rst  : input  reset            ,
    din  : input  logic<WORD_WIDTH>,
    empty: input  logic            ,
    re   : output logic            ,
    dout : output logic            ,
) {
    // constant
    const ONE_CYCLE: logic<32> = CLOCK_FREQUENCY / BAUD_RATE;

    // type definition
    enum state_t {
        WAIT = 3'h0,
        SEND_ENABLE = 3'h1,
        LOAD_DATA = 3'h2,
        TRANSMIT_START_BIT = 3'h3,
        TRANSMIT_DATA_BIT = 3'h4,
        TRANSMIT_STOP_BIT = 3'h5,
    }

    // registers and wires
    var state           : state_t            ;
    var data            : logic  <WORD_WIDTH>;
    var clocks          : logic  <32>        ;
    var transmitted_bits: logic  <32>        ;
    var full_clocks     : logic              ;

    // logics
    always_ff {
        if_reset {
            re = 1'b0;
        } else {
            re = case state {
                state_t::WAIT: ~empty,
                default      : 1'b0,
            };
        }
    }

    assign dout = case state {
        state_t::TRANSMIT_START_BIT: 1'b0,
        state_t::TRANSMIT_DATA_BIT : data[0],
        default                    : 1'b1,
    };

    always_ff {
        if_reset {
            state = state_t::WAIT;
        } else {
            state = case state {
                state_t::WAIT              : if ~empty ? state_t::SEND_ENABLE : state,
                state_t::SEND_ENABLE       : state_t::LOAD_DATA,
                state_t::LOAD_DATA         : state_t::TRANSMIT_START_BIT,
                state_t::TRANSMIT_START_BIT: if full_clocks ? state_t::TRANSMIT_DATA_BIT : state,
                state_t::TRANSMIT_DATA_BIT : if full_clocks && (transmitted_bits == (WORD_WIDTH - 1)) ? state_t::TRANSMIT_STOP_BIT : state,
                state_t::TRANSMIT_STOP_BIT : if full_clocks ? state_t::WAIT : state,
                default                    : state,
            };
        }
    }

    always_ff {
        if_reset {
            data = {1'b1 repeat WORD_WIDTH + 1};
        } else {
            data = case state {
                state_t::LOAD_DATA        : din,
                state_t::TRANSMIT_DATA_BIT: if full_clocks ? {1'b1, data[WORD_WIDTH - 1:1]} : data,
                default                   : data,
            };
        }
    }

    always_ff {
        if_reset {
            clocks = 32'h0;
        } else {
            clocks = case state {
                state_t::TRANSMIT_START_BIT, state_t::TRANSMIT_DATA_BIT, state_t::TRANSMIT_STOP_BIT: if full_clocks ? 32'h0 : clocks + 32'h1,
                default                                                                            : 32'h0,
            };
        }
    }

    always_ff {
        if_reset {
            transmitted_bits = 32'h0;
        } else {
            transmitted_bits = case state {
                state_t::TRANSMIT_DATA_BIT: if full_clocks ? transmitted_bits + 32'h1 : transmitted_bits,
                default                   : 32'h0,
            };
        }
    }

    assign full_clocks = clocks == (ONE_CYCLE - 1);
}
