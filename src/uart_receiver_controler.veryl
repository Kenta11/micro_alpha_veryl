module uart_receiver_controler #(
    param CLOCK_FREQUENCY: logic<32> = 32'd100_000_000,
    param BAUD_RATE      : logic<32> = 32'd115200     ,
    param WORD_WIDTH     : logic<32> = 32'd8          ,
) (
    clk : input  clock            ,
    rst : input  reset            ,
    din : input  logic            ,
    dout: output logic<WORD_WIDTH>,
    full: input  logic            ,
    we  : output logic            ,
) {
    // constants
    const ONE_CYCLE: logic<32> = CLOCK_FREQUENCY / BAUD_RATE;

    // type definition
    enum state_t {
        WAIT = 3'h0,
        IGNORE_DATA_BIT = 3'h1,
        RECEIVE_DATA_BIT = 3'h2,
        RECEIVE_STOP_BIT = 3'h3,
        WRITE_WORD = 3'h4,
    }

    // registers and wires
    var state             : state_t           ;
    var clocks            : logic  <32>       ;
    var seq               : logic  <ONE_CYCLE>;
    var zeros             : logic  <32>       ;
    var received_bits     : logic  <32>       ;
    var received_start_bit: logic             ;
    var received_a_word   : logic             ;
    var half_clocks       : logic             ;
    var full_clocks       : logic             ;

    // logics
    always_ff {
        if_reset {
            dout = {1'b0 repeat WORD_WIDTH};
        } else {
            dout = case state {
                state_t::RECEIVE_DATA_BIT: if full_clocks ? {zeros <= (ONE_CYCLE / 2), dout[WORD_WIDTH - 1:1]} : dout,
                default                  : dout,
            };
        }
    }

    assign we = state == state_t::WRITE_WORD;

    always_ff {
        if_reset {
            state = state_t::WAIT;
        } else {
            state = case state {
                state_t::WAIT            : if received_start_bit ? state_t::IGNORE_DATA_BIT : state,
                state_t::IGNORE_DATA_BIT : if half_clocks ? state_t::RECEIVE_DATA_BIT : state,
                state_t::RECEIVE_DATA_BIT: if received_a_word ? state_t::RECEIVE_STOP_BIT : state,
                state_t::RECEIVE_STOP_BIT: if full_clocks ? (if (zeros <= (ONE_CYCLE / 2)) && (~full) ? state_t::WRITE_WORD : state_t::WAIT) : state,
                state_t::WRITE_WORD      : state_t::WAIT,
                default                  : state,
            };
        }
    }

    always_ff {
        if_reset {
            clocks = 32'h0;
        } else {
            clocks = case state {
                state_t::IGNORE_DATA_BIT                            : if half_clocks ? 32'h0 : clocks + 32'h1,
                state_t::RECEIVE_DATA_BIT, state_t::RECEIVE_STOP_BIT: if full_clocks ? 32'h0 : clocks + 32'h1,
                default                                             : 32'h0,
            };
        }
    }

    always_ff {
        if_reset {
            seq = {1'b1 repeat ONE_CYCLE};
        } else {
            seq = if full_clocks ? {1'b1 repeat ONE_CYCLE} : {seq[ONE_CYCLE - 2:0], din};
        }
    }

    always_ff {
        if_reset {
            zeros = 32'h0;
        } else {
            zeros = if full_clocks ? 32'h0 : zeros - (~seq[ONE_CYCLE - 1]) + (~din);
        }
    }

    always_ff {
        if_reset {
            received_bits = 4'h0;
        } else {
            received_bits = case state {
                state_t::RECEIVE_DATA_BIT: if full_clocks ? received_bits + 4'h1 : received_bits,
                default                  : 4'h0,
            };
        }
    }

    assign received_start_bit = case state {
        state_t::WAIT: zeros == (ONE_CYCLE / 2),
        default      : 1'b0,
    };

    assign received_a_word = case state {
        state_t::RECEIVE_DATA_BIT: full_clocks && (received_bits == 4'h7),
        default                  : 1'b0,
    };

    assign half_clocks = clocks == (ONE_CYCLE / 2);
    assign full_clocks = clocks == (ONE_CYCLE - 1);
}
