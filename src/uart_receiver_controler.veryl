module uart_receiver_controler #(
    param CLOCK_FREQUENCY: logic<32> = 32'd100_000_000,
    param BAUD_RATE      : logic<32> = 32'd115200     ,
    param WORD_WIDTH     : logic<32> = 32'd8          ,
) (
    clk : input  clock            ,
    rst : input  reset            ,
    din : input  logic            ,
    dout: output logic<WORD_WIDTH>,
    full: input  logic            ,
    we  : output logic            ,
) {
    // constants
    const ONE_CYCLE: logic<32> = CLOCK_FREQUENCY / BAUD_RATE;

    // type definition
    enum state_t {
        WAIT = 3'h0,
        IGNORE_DATA_BIT = 3'h1,
        RECEIVE_DATA_BIT = 3'h2,
        RECEIVE_STOP_BIT = 3'h3,
        WRITE_WORD = 3'h4,
    }

    // registers and wires
    var state             : state_t           ;
    var clocks            : logic  <32>       ;
    var seq               : logic  <ONE_CYCLE>;
    var zeros             : logic  <32>       ;
    var received_bits     : logic  <32>       ;
    var received_start_bit: logic             ;
    var received_a_word   : logic             ;
    var half_clocks       : logic             ;
    var full_clocks       : logic             ;

    // logics
    always_ff {
        if_reset {
            dout = {1'b0 repeat WORD_WIDTH};
        } else {
            case state {
                state_t::RECEIVE_DATA_BIT: dout = if full_clocks ? {zeros <= (ONE_CYCLE / 2), dout[WORD_WIDTH - 1:1]} : dout;
                default                  : dout = dout;
            }
        }
    }

    assign we = (state == state_t::WRITE_WORD);

    always_ff {
        if_reset {
            state = state_t::WAIT;
        } else {
            case state {
                state_t::WAIT            : state = if received_start_bit ? state_t::IGNORE_DATA_BIT : state;
                state_t::IGNORE_DATA_BIT : state = if half_clocks ? state_t::RECEIVE_DATA_BIT : state;
                state_t::RECEIVE_DATA_BIT: state = if received_a_word ? state_t::RECEIVE_STOP_BIT : state;
                state_t::RECEIVE_STOP_BIT: state = if full_clocks ? (if ((zeros <= (ONE_CYCLE / 2)) && (~full)) ? state_t::WRITE_WORD : state_t::WAIT) : state;
                state_t::WRITE_WORD      : state = state_t::WAIT;
                default                  : state = state;
            }
        }
    }

    always_ff {
        if_reset {
            clocks = 32'h0;
        } else {
            case state {
                state_t::IGNORE_DATA_BIT : clocks = if half_clocks ? 32'h0 : clocks + 32'h1;
                state_t::RECEIVE_DATA_BIT: clocks = if full_clocks ? 32'h0 : clocks + 32'h1;
                state_t::RECEIVE_STOP_BIT: clocks = if full_clocks ? 32'h0 : clocks + 32'h1;
                default                  : clocks = 32'h0;
            }
        }
    }

    always_ff {
        if_reset {
            seq = {1'b1 repeat ONE_CYCLE};
        } else if (full_clocks) {
            seq = {1'b1 repeat ONE_CYCLE};
        } else {
            seq = {seq[ONE_CYCLE - 2:0], din};
        }
    }

    always_ff {
        if_reset {
            zeros = 32'h0;
        } else if (full_clocks) {
            zeros = 32'h0;
        } else {
            zeros = zeros - (~seq[ONE_CYCLE - 1]) + (~din);
        }
    }

    always_ff {
        if_reset {
            received_bits = 4'h0;
        } else {
            case state {
                state_t::RECEIVE_DATA_BIT: received_bits = if full_clocks ? received_bits + 4'h1 : received_bits;
                default                  : received_bits = 4'h0;
            }
        }
    }

    always_comb {
        case state {
            state_t::WAIT: received_start_bit = (zeros == (ONE_CYCLE / 2));
            default      : received_start_bit = 1'b0;
        }
    }

    always_comb {
        case state {
            state_t::RECEIVE_DATA_BIT: received_a_word = full_clocks && (received_bits == 4'h7);
            default                  : received_a_word = 1'b0;
        }
    }

    assign half_clocks = (clocks == (ONE_CYCLE / 2));
    assign full_clocks = (clocks == (ONE_CYCLE - 1));
}
